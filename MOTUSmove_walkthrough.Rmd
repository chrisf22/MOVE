---
title: "MOTUS movement model walkthrough"
author: "Christopher R Field"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message=FALSE)
```

### Model basics

The following example shows the basic principles behind a general modeling framework for inferring movements from MOTUS data. These principles are shown for the movements of a single individual, but they can be scaled up to a population or group of species. 

The approach, simplified from the methods in Baldwin et al (2018) and Jonsen (2016), is built around a multivariate normal distribution that models movements in an x and y dimension. In its most basic version, this distribution makes it possible to estimate the parameters that describe Brownian motion: from the first know location of an individual, the next movement is determined by random movements in the x and y direction, which are allowed to be correlated. We assume that the process that governs the magnitude of these movements can be described by parameters for the variance (one parameter for x and one for y) and the correlation between x and y. This assumed process is shown for ten movements below.


```{r }
library(MASS)
XA <- mat.or.vec(10, 2)
Sigma <- matrix(c(0.25, 0.03125, 0.03125, 1), nrow = 2)
XA[1,] <- mvrnorm(n = 1, c(-72, 41), Sigma = Sigma)
for(i in 1:9){
  XA[i+1,] <- mvrnorm(n = 1, XA[i,],  Sigma = Sigma)
}
plot(XA[1, 1], XA[1, 2], xlim=c(min(XA[,1])-1, max(XA[,1])+1), ylim=c(min(XA[,2])-1, max(XA[,2])+1), 
     pch = 16, col = rgb(0, 0, 0, 0), xlab="Longitude", ylab="Latitude")
for(i in 1:9){
  points(XA[i, 1], XA[i, 2], pch=16, col = rgb(0, 0, 0, 0.3))
  arrows(XA[i, 1], XA[i, 2], XA[i+1, 1], XA[i+1, 2], lend="butt", length = 0.1)
}
points(XA[10, 1], XA[10, 2], pch = 16, col = rgb(0, 0, 0, 0.3))
                
```

### Adding correlation in the magnitude of movement

From this basic framework, we can add complexity to better represent the movements of birds during the time period of the life cycle of interest (e.g. post-breeding dispersal, migratory staging, or migration). Here I present three extensions that make it possible to relax restrictive assumptions and avoid major biases in parameter estimation. One extension that might be useful is allowing for correlation in the magnitude between successive movements. For example, if an individual's last movement was a short hop, the next movement is more likely to be short as well. A correlation parameter, gamma, determines the strength of this correlation, with a value of zero being the state where the magnitudes of movements are completely independent of previous movements. Baldwin et al. (2018), allow the state of gamma to shift over time, but here we use one state for gamma. The influence on this assumed movement process of including a relatively strong correlation parameter (gamma = 0.7) is shown below in red for ten movements (the simpler process is shown for reference).


```{r }
XB <- mat.or.vec(10, 2)
Sigma <- matrix(c(0.25, 0.03125, 0.03125, 1), nrow = 2)
XB[1,] <- XA[1,]
#XB[1,] <- mvrnorm(n = 1, c(-72, 41),  Sigma = Sigma)
XB[2,] <- mvrnorm(n = 1, XB[1,],  Sigma = Sigma)
for(i in 2:9){
  XB2 <- (XB[i, ] - XB[i-1,])*0.7 + XB[i, ]
  XB[i+1,] <- mvrnorm(n = 1, XB2,  Sigma = Sigma)
}

plot(XA[1, 1], XA[1, 2], xlim=c(min(c(XA[,1], XB[,1]))-1, max(c(XA[,1], XB[,1]))+1), ylim=c(min(c(XA[,2], XB[,2]))-1, max(c(XA[,2], XB[,2]))+1), 
     pch = 16, col = rgb(0, 0, 0, 0), xlab="Longitude", ylab="Latitude")
for(i in 1:9){
  points(XA[i, 1], XA[i, 2], pch=16, col = rgb(0, 0, 0, 0.3))
  arrows(XA[i, 1], XA[i, 2], XA[i+1, 1], XA[i+1, 2], lend="butt", length = 0.1)
}
points(XA[10, 1], XA[10, 2], pch = 16, col = rgb(0, 0, 0, 0.3))


#plot(XB[1, 1], XB[1, 2], xlim=c(min(XB[,1])-1, max(XB[,1])+1), ylim=c(min(XB[,2])-1, max(XB[,2])+1), 
#     pch = 16, col = rgb(0, 0, 0, 0), xlab="Longitude", ylab="Latitude")
for(i in 1:9){
  points(XB[i, 1], XB[i, 2], pch=16, col = rgb(1, 0, 0, 0.3))
  arrows(XB[i, 1], XB[i, 2], XB[i+1, 1], XB[i+1, 2], lend="butt", length = 0.1, col = rgb(1, 0, 0, 1))
}
points(XB[10, 1], XB[10, 2], pch = 16, col = rgb(1, 0, 0, 0.3))
                
```

### Adding directional drift

One additional extension is allowing for a tendency to drift in a particular direction over time. For example, an individual during migratory staging might make random movements that can be in any direction but have a greater tendency to be in a south-western direction. When specifying this process to develop a model for statistical inference, the strength and direction of this tendency to drift can be specified with greater or lesser certainty, depending on the prior information that is available. The influence of including a relatively strong drift parameter (D[x] = -1 decimal degree; D[y] = -1) is shown in green for ten movements.


```{r }
XC <- mat.or.vec(10, 2)
Sigma <- matrix(c(0.25, 0.03125, 0.03125, 1), nrow = 2)
#XC[1,] <- mvrnorm(n = 1, c(-72, 41),  Sigma = Sigma)
XC[1,] <- XA[1,]
XC[2,] <- mvrnorm(n = 1, XC[1,],  Sigma = Sigma)
for(i in 2:9){
  XC2 <- (XC[i, ] - XC[i-1,])*0.7 + XC[i, ] - 1
  XC[i+1,] <- mvrnorm(n = 1, XC2,  Sigma = Sigma)
}

plot(XA[1, 1], XA[1, 2], xlim=c(min(c(XA[,1], XB[,1], XC[,1]))-1, max(c(XA[,1], XB[,1], XC[,1]))+1), ylim=c(min(c(XA[,2], XB[,2], XC[,2]))-1, max(c(XA[,2], XB[,2], XC[,2]))+1), 
     pch = 16, col = rgb(0, 0, 0, 0), xlab="Longitude", ylab="Latitude")
for(i in 1:9){
  points(XA[i, 1], XA[i, 2], pch=16, col = rgb(0, 0, 0, 0.3))
  arrows(XA[i, 1], XA[i, 2], XA[i+1, 1], XA[i+1, 2], lend="butt", length = 0.1)
}
points(XA[10, 1], XA[10, 2], pch = 16, col = rgb(0, 0, 0, 0.3))

for(i in 1:9){
  points(XB[i, 1], XB[i, 2], pch=16, col = rgb(1, 0, 0, 0.3))
  arrows(XB[i, 1], XB[i, 2], XB[i+1, 1], XB[i+1, 2], lend="butt", length = 0.1, col = rgb(1, 0, 0, 1))
}
points(XB[10, 1], XB[10, 2], pch = 16, col = rgb(1, 0, 0, 0.3))


#plot(XC[1, 1], XC[1, 2], xlim=c(min(XC[,1])-1, max(XC[,1])+1), ylim=c(min(XC[,2])-1, max(XC[,2])+1), 
#     pch = 16, col = rgb(0, 0, 0, 0), xlab="Longitude", ylab="Latitude")
for(i in 1:9){
  points(XC[i, 1], XC[i, 2], pch=16, col = rgb(0, 1, 0, 0.3))
  arrows(XC[i, 1], XC[i, 2], XC[i+1, 1], XC[i+1, 2], lend="butt", length = 0.1, col = rgb(0, 1, 0, 1))
}
points(XC[10, 1], XC[10, 2], pch = 16, col = rgb(0, 1, 0, 0.3))

```

### Accouting for physiological or behavioral constraints

A process that includes random movements as well as drift might result in movements that are larger than physiological or behavioral constraints of the species of interest. To address this, we can include a constraint by specifying the maximum distance an individual can move per day. The influence of including this constraint (maximum of 1.25 decimal degrees/day in either the x or y direction) is shown in blue for ten movements.


```{r}
XD <- mat.or.vec(10, 2)
Sigma <- matrix(c(0.25, 0.03125, 0.03125, 1), nrow = 2)
#XD[1,] <- mvrnorm(n = 1, c(-72, 41),  Sigma = Sigma)
XD[1,] <- XA[1,]
XD[2,] <- mvrnorm(n = 1, XD[1,],  Sigma = Sigma)
for(i in 2:9){
  XD2x <- max(-1.25, min((XD[i, 1] - XD[i-1, 1])*0.7 - 1, 1.25)) + XD[i, 1]
  XD2y <- max(-1.25, min((XD[i, 2] - XD[i-1, 2])*0.7 - 1, 1.25)) + XD[i, 2] 
  XD[i+1,] <- mvrnorm(n = 1, c(XD2x, XD2y),  Sigma = Sigma)
}

plot(XA[1, 1], XA[1, 2], xlim=c(min(c(XA[,1], XB[,1], XC[,1], XD[,1]))-1, max(c(XA[,1], XB[,1], XC[,1], XD[,1]))+1), ylim=c(min(c(XA[,2], XB[,2], XC[,2], XD[,2]))-1, max(c(XA[,2], XB[,2], XC[,2], XD[,2]))+1), 
     pch = 16, col = rgb(0, 0, 0, 0), xlab="Longitude", ylab="Latitude")
for(i in 1:9){
  points(XA[i, 1], XA[i, 2], pch=16, col = rgb(0, 0, 0, 0.3))
  arrows(XA[i, 1], XA[i, 2], XA[i+1, 1], XA[i+1, 2], lend="butt", length = 0.1)
}
points(XA[10, 1], XA[10, 2], pch = 16, col = rgb(0, 0, 0, 0.3))

for(i in 1:9){
  points(XB[i, 1], XB[i, 2], pch=16, col = rgb(1, 0, 0, 0.3))
  arrows(XB[i, 1], XB[i, 2], XB[i+1, 1], XB[i+1, 2], lend="butt", length = 0.1, col = rgb(1, 0, 0, 1))
}
points(XB[10, 1], XB[10, 2], pch = 16, col = rgb(1, 0, 0, 0.3))

for(i in 1:9){
  points(XC[i, 1], XC[i, 2], pch=16, col = rgb(0, 1, 0, 0.3))
  arrows(XC[i, 1], XC[i, 2], XC[i+1, 1], XC[i+1, 2], lend="butt", length = 0.1, col = rgb(0, 1, 0, 1))
}
points(XC[10, 1], XC[10, 2], pch = 16, col = rgb(0, 1, 0, 0.3))


#plot(XD[1, 1], XD[1, 2], xlim=c(min(XD[,1])-1, max(XD[,1])+1), ylim=c(min(XD[,2])-1, max(XD[,2])+1), 
#     pch = 16, col = rgb(0, 0, 0, 0), xlab="Longitude", ylab="Latitude")
for(i in 1:9){
  points(XD[i, 1], XD[i, 2], pch=16, col = rgb(0, 0, 1, 0.3))
  arrows(XD[i, 1], XD[i, 2], XD[i+1, 1], XD[i+1, 2], lend="butt", length = 0.1, col = rgb(0, 0, 1, 1))
}
points(XD[10, 1], XD[10, 2], pch = 16, col = rgb(0, 0, 1, 0.3))
                
```

### The consequences of adding unwarranted complexity

One challenge to using a general framework - e.g. one that includes parameters for all of the above extensions - is that not all extensions will apply to every species or time period. Some trade-offs associated with using the same general framework for all species are more acceptable than others. One consequence of unwarranted complexity is larger uncertainty bounds on the parameters of interest, but this trade-off might be worth it for the convenience of a general framework. If the unwarranted complexity biases parameter estimation, however, a more specific implementation of the framework is likely necessary. To show the results of estimating unnecessary parameters, we used a simple simulation that did not have correlation (gamma) or drift (D) as part of the underlying process. We then used this fit the general framework, that includes those parameters, to these simulated, known, data. The parameter estimates for gamma and D are shown below. Both are centered on zero (i.e. no effect) suggesting that including them is not likely to bias the other parameters of interest.


```{r}
library(R2jags)
library(R2WinBUGS)

XE <- mat.or.vec(100, 2)
Sigma <- matrix(c(0.25, 0.03125, 0.03125, 1), nrow = 2)
XE[1,] <- mvrnorm(n = 1, c(-72, 41), Sigma = Sigma)
for(i in 1:99){
  XE[i+1,] <- mvrnorm(n = 1, XE[i,],  Sigma = Sigma)
}
x <- XE

MOVE <- function(){
  # priors on process uncertainty
  Omega[1, 1] <- 1
  Omega[1, 2] <- 0
  Omega[2, 1] <- 0
  Omega[2, 2] <- 1
  
  iSigma[1:2, 1:2] ~ dwish(Omega[, ], 2)
  Sigma[1:2, 1:2] <- inverse(iSigma[, ])
  gamma ~ dunif(0, 1)
  
  D[1] ~ dunif(-1, 1)
  D[2] ~ dunif(-1, 1)
  
  x[2, 1:2] ~ dmnorm(x[1, ], iSigma[, ])
    for(t in 2:99){ 
      displace[t, 1] <- max(-1, min((x[t, 1] - x[t-1, 1])*gamma + D[1], 1))
      displace[t, 2] <- max(-1, min((x[t, 2] - x[t-1, 2])*gamma + D[2], 1))
      x.mn[t, 1:2] <- x[t, 1:2] + displace[t, 1:2]
      x[t+1, 1:2] ~ dmnorm(x.mn[t, ], iSigma[, ])
    }
  #end function
}

if (is.R()){
  filename <- file.path(tempdir(), "MOVE.bug")}
write.model(MOVE, filename)
inits <- list(list(gamma=0.5))
data <- list("x")
parameters <- c("gamma", "iSigma", "x", "D")
MOVE <- jags(data=data, inits=inits, parameters.to.save=parameters, filename,
             n.chains=1, n.burnin=1000, n.iter=5000, n.thin=1, DIC=TRUE)
MOVE.mcmc <- as.mcmc(MOVE)

gamma <- MOVE$BUGSoutput$sims.array[, , "gamma"]
D <- MOVE$BUGSoutput$sims.array[, , "D[1]"]

hist(D, main=" ")
hist(gamma, main=" ")


```
